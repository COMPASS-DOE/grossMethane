---
title: "CH4_PoolDilution"
author: "Kendalynn A. Morris"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}

#load packages
library(PoolDilutionR)
library(dplyr)
library(ggplot2)
library(ggpmisc)
library(ggh4x)
library(lubridate)
library(readr)
library(scales)
library(tibble)
library(tidyr)
library(kableExtra)

theme_set(theme_minimal() + theme(text = element_text(size = 11)))
```

# Methane Pool Dilution

This code calculates gross methane production and consumption from pool dilution time series data. Methane concentrations and 13C content are measured from a closed system over time, the model optimizes production rate (P) and the first order rate constant (k), by minimizing error in the model-predicted total methane content, as well as the isotopic signature.The model optimizes rates by weighting information against the signal:noise ratio of concentration and 13C-signatures using measurement precision as well as the magnitude of change over time. The calculations used here are based on von Fischer and Hedin 2002, 10.1029/2001GB001448, with some modifications (see text below).  

Original code was written for data collected on a Picarro CRDS equipped with a SSIM2 unit.  

### Step 1: Read in data...  
```{r Read & Clean Data, echo = FALSE, message = TRUE}
# Get names of data files
files <- list.files("picarro/", pattern = "*.csv", full.names = TRUE)
# Helper function
read_file <- function(f) {
    message("Reading ", f)
    read_csv(f, col_types = "ccdcddcddddddddddddddddddddddccccc") %>%
        mutate(File = basename(f))
}
# Read in and pre-process data
lapply(files, read_file) %>%
    bind_rows() %>%
    # filter out standards and clean up columns
    filter(! id %in% c("SERC100ppm", "UMDzero", "SERCzero", "desert5000")) %>%
    mutate(Timestamp = mdy_hm(`Date/Time`, tz = "UTC")) %>%
    select(Timestamp, id, round, vol,
           `HR 12CH4 Mean`, `HR 12CH4 Std`,
           #HR stands for High Resolution
           `HR 13CH4 Mean`, `HR 13CH4 Std`,
           `HR Delta iCH4 Mean`, `HR Delta iCH4 Std`,
           `12CO2 Mean`, `12CO2 Std`,
           `13CO2 Mean`, `13CO2 Std`,
           `Delta 13CO2 Mean`, `Delta 13CO2 Std`,
           notes) %>%
    # calculate elapsed time for each sample
    arrange(id, round) %>%
    group_by(id) %>%
    mutate(time_days = difftime(Timestamp, min(Timestamp),
                                units = "days"),
           time_days = as.numeric(time_days)) ->
    incdat_raw

summary(incdat_raw)
```
```{r Set Constants, echo=FALSE}
FRAC_K <- 0.98 # 13C consumption as a fraction of 12C consumption (alpha in Eq. 11)
FRAC_P <- 0.01 # 13C production as a fraction of 12C production
AP_P <- FRAC_P / (1 + FRAC_P) * 100 # 13C atom percent of total methane production
VOL_ML <- 130  # total volume of jar
```

### Step 2: Convert units and calculate time steps and normalization factors...  
```{r Convert Units, echo=TRUE}
incdat_raw %>%
    # Volume of jar = 130 ml or 0.130 L, 1 ppm = 0.001 ml/L
    # The Picarro measures 20 ml, but 10 ml injected (see vol);
    # So ppm is a 1:1 dilution (1 part sample to 1 part dilutant)
    # therefore ppm to ml = ppm * 0.001 * VOL_ML/1000 * 2
    mutate(cal12CH4ml = `HR 12CH4 Mean` * 0.001 * VOL_ML/1000 * 2 * 1000,
           cal13CH4ml = `HR 13CH4 Mean` * 0.001 * VOL_ML/1000 * 2 * 1000,
           # for each 10 ml sample from 130 ml jar,
           # 10 ml of zero air injected
           # 12 parts sample to 1 part dilutant (13 parts total)
           # remaining gas in jar is diluted 12:1
           cal12CH4ml = if_else(round != "T0", cal12CH4ml * 1.083, cal12CH4ml),
           cal13CH4ml = if_else(round != "T0", cal13CH4ml * 1.083, cal13CH4ml),
           # calculate atom percent (AP) of 13C methane in sample over time
           AP_obs = cal13CH4ml / (cal12CH4ml + cal13CH4ml) * 100,
           sdC = `HR 12CH4 Std`, sdD = `HR Delta iCH4 Std`) ->
    incdat

#now we generate sample specific scaling factors for feeding into a cost function
#see vFH2002 Eqs. 12, 13, & 14
#need standard deviation of isotopes and mass across all measurements for each sample -> sd_obs
#and standard deviation of the analytical precision aka
#instrument stdev for those observations -> sd_inst
incdat %>% 
    group_by(id) %>% 
    mutate(sd_obsDelta = sd(`HR Delta iCH4 Mean`),
           sd_instDelta = sd(sdD),
           #sdD is the instrument stdev for the delta measurement
           sd_obsMass = sd(`HR 12CH4 Mean`),
           sd_instMass = sd(sdC),
           #sdC is the instrument stdev for the 12C mass measurement
           Nd = sd_obsDelta/sd_instDelta,
           Nm = sd_obsMass/sd_instMass) -> incdat
```

#### Input Data

```{r Input Data Visualization, echo=FALSE}
facet_labels <- c(
    AP_obs = "Atom% Observed",
    cal12CH4ml = "12C Methane (mL)",
    cal13CH4ml = "13C Methane (mL)")

incdat %>%
    filter(id %in% c("2","31","52","61","64","71")) %>%  
    mutate(id_numeric = as.factor(id)) %>%
    pivot_longer(cols = c(cal12CH4ml, cal13CH4ml, AP_obs)) %>%
    ggplot(aes(round, value, group = id, color = id)) +
    scale_color_discrete("Sample ID") +
    geom_point() + geom_line() + ylab("") + xlab("\n Timestep") +
    ggtitle("Example Input Data") +
    facet_wrap( ~ name, scales = "free",
                labeller = labeller(name = facet_labels)) -> p
print(p)
```

### Step 3: Atom Precent Prediction  

Prediction function\
time: vector of time values, numeric (e.g. days); first should be zero\
m0: amount of total methane at time zero\
n0: amount of labeled methane at time zero\
P: production rate of total methane, unit gas/unit time\
k: first-order rate constant for methane consumption, 1/unit time\
Returns a data frame with mt, nt, and AP (atom percent) predictions for each time step\
All combined, this is Eq. 11 from vFH2002 with a few modifications...\
1. Added x 100 so that the left part is correctly a percent (per their Appendix A)\
2. Removed addition of AP_P from Eq. 10 & 11, see notes in ReadMe\
3. Expanded Eq. 9 (and numerator in Eq. 11) to include both production and consumption terms for 13C methane (ie., naturally occuring heavy methane)\

### Step 4: Cost Function  

Called by optim()\
params: named vector holding optimizer-assigned values for P and k\
time: vector of time values, numeric (e.g. days); first should be zero\
m: observed total methane values, same length as time\
n: observed labeled methane values, same length as time\
Nd: normalization factor for delta values, see Eq. 12\
Nm: normalization factor for methane mass, see Eq. 13\
Returns the sum of squares between predicted and observed m and AP\

### Step 5: optimize P and k, then calculate consumption rate (C)  

```{r Do the thing!, echo=TRUE, message = FALSE, warning = FALSE, results='hide'}
pk_results <- list()
incdat_out <- list()

for(i in unique(incdat$id)) {
    message("------------------- ", i)
    # Isolate this sample's data
    incdat %>%
        filter(id == i) %>%
        select(id, round, vol, time_days,
               cal12CH4ml, cal13CH4ml,
               AP_obs, Nm, Nd) ->
        dat
    
    # Let optim() try different values for P and k until it finds best fit to data
    params <- list("P0" = 10) # k0 is auto-estimated
    result <- optimize_pk(time = dat$time_days,
                          m = dat$cal12CH4ml + dat$cal13CH4ml,
                          n = dat$cal13CH4ml,
                          Nm = dat$Nm,
                          Nd = dat$Nd,
                          params = params)
    
    message("Optimizer solution:")
    print(result)
    P <- result$par["P"]
    pk_results[[i]] <- tibble(P = P,
                              k = result$par["k"],
                              k0 = result$initial_par["k0"],
                              convergence = result$convergence,
                              message = result$message)
    
    # Predict based on the optimized parameters
    pred <- ap_prediction(time = dat$time_days,
                          m0 = dat$cal12CH4ml[1] + dat$cal13CH4ml[1],
                          n0 = dat$cal13CH4ml[1],
                          P = P,
                          k = result$par["k"])
    dat <- bind_cols(dat, pred)
    
    # Calculate implied consumption (ml/day) based on predictions
    # Ct = (P*time - ([CH4t] - [CH4t-1]))/time
    # or expressed in the notation of Equation 4: dm/dt = P - C
    # so C = P - dm/dt
    # (could also just use equation 2, but this is a good check on things)
    total_methane <- dat$cal12CH4ml + dat$cal13CH4ml
    change_methane <- c(0, diff(total_methane))
    change_time <- c(0, diff(dat$time_days))
    dat$Pt <- P * change_time
    dat$Ct <- (-change_methane + (P * change_time)) / change_time
    
    incdat_out[[i]] <- dat
}
```

```{r Wrap it up!, echo=FALSE, message = FALSE}
pk_results <- bind_rows(pk_results, .id = "id")
incdat_out <- bind_rows(incdat_out)

incdat_out %>%
    # compute correlation between predictions and observations
    group_by(id) %>%
    summarise(m_cor = cor(cal12CH4ml + cal13CH4ml, mt),
              ap_cor = cor(AP_obs, AP_pred)) ->
    performance_summary

performance_summary %>%
    right_join(pk_results, by = "id") ->
    pk_results
print(pk_results)

pk_results %>%
    right_join(incdat_out, by = "id") ->
    incdat_out
```

# Results  

```{r Summarize Output}
summary(incdat_out)
```

# Summary Plots  

```{r Summary Plots, echo = FALSE}
# ----- Plot AP results -----
incdat_out %>%
    filter(id %in% c("2","31","52","61","64","71")) %>%
    ggplot(aes(round, AP_obs, color = as.factor(id))) +
    geom_point(aes(shape = ""), size = 3.75) +
    geom_line(aes(round, AP_pred, group = id, linetype = ""), linewidth = 1.25) +
    scale_linetype_manual(name = "Prediction",
                          values = "dotted") +
    scale_shape_manual(name = "Observations",
                       values = 20) +
    scale_color_discrete(guide = "none") +
    facet_wrap(~as.numeric(id), scales = "free") +
    xlab("\n Timestep \n") + ylab("\n (13C-CH4/Total CH4) x 100 \n") +
    ggtitle("\n Atom% 13C \n") + theme(legend.position = "bottom")


# ----- Plot total methane results -----
incdat_out %>%
    filter(id %in% c("2","31","52","61","64","71")) %>%
    ggplot(aes(round, cal12CH4ml + cal13CH4ml, color = as.factor(id))) +
    geom_point(aes(shape = ""), size = 3.75) +
    geom_line(aes(round, mt, group = id, linetype = ""), linewidth = 1.25) +
    scale_linetype_manual(name = "Prediction",
                          values = "dotted") +
    scale_shape_manual(name = "Observations",
                       values = 20) +
    scale_color_discrete(guide = "none") +
    facet_wrap(~as.numeric(id), scales = "free") +
    xlab("\n Timestep \n") + ylab("\n Volume (mL) \n") +
    ggtitle("\n Total Methane \n") + theme(legend.position = "bottom")
```


```{r Fit Trends, echo = FALSE}
# ----- Visualize data, coloring by fit -----
incdat_out %>%
    filter(id %in% c("2","31","52","61","64","71")) %>%  
    pivot_longer(cols = c(cal12CH4ml, cal13CH4ml, AP_obs)) %>%
    ggplot(aes(round, value, group = id, color = ap_cor)) +
    geom_point() + geom_line() + xlab("\n Timestep") +
    ylab("") + scale_color_continuous(name = "Goodness of Fit") +
    facet_wrap( ~ name, scales = "free",
                labeller = labeller(name = facet_labels)) +
    ggtitle("Fit Trends") + theme(legend.position = "bottom")

```


```{r Results Table, echo = FALSE}
incdat_out %>%
    filter(id %in% c("2","31","52","61","64","71"),
           round == "T1") %>%
    select(id, P, k, Ct, AP_pred, AP_obs) %>%
    mutate(across(where(is.numeric), ~ num(., digits = 2))) -> results

kable(results,
      caption = "<center><strong>Gross Rates</strong></center>",
      escape = FALSE,
      col.names = NULL,
      align = "c",
      format = "html") %>%
    kable_styling(font_size = 12) %>% 
  add_header_above(c("Sample ID", "P mL/day", "k 1/day", "C mL/day", "Atom% Predicted", "Atom% Observed"))
```
