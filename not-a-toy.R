library(tibble)
library(ggplot2)
library(ggpmisc)
library(dplyr)
library(tidyr)
library(readr)
library(lubridate)
theme_set(theme_bw())


# ----- Read in and clean up data -----

# Get names of data files
files <- list.files("picarro/", pattern = "*.csv", full.names = TRUE)
# Helper function
read_file <- function(f) {
    message("Reading ", f)
    read_csv(f, col_types = "ccdcddcddddddddddddddddddddddccccc") %>%
        mutate(File = basename(f))
}
# Read in and pre-process data
lapply(files, read_file) %>%
    bind_rows() %>%
    # filter out test data (???) and clean up columns
    filter(! id %in% c("SERC100ppm", "UMDzero", "SERCzero", "desert5000")) %>%
    mutate(Timestamp = mdy_hm(`Date/Time`, tz = "UTC")) %>%
    select(Timestamp, id, round, vol,
           `HR 12CH4 Mean`, `HR 13CH4 Mean`, notes) %>%
    # calculate elapsed time for each sample
    arrange(id, round) %>%
    group_by(id) %>%
    mutate(time_days = difftime(Timestamp, min(Timestamp),
                                units = "days"),
           time_days = as.numeric(time_days)) ->
    incdat_raw

# ----- QA/QC -----

# Each of the samples has a vol=2, round=T4 observation with bizarre data
# I assume we want to drop it?
incdat <- filter(incdat_raw, vol > 2)
# The id 10 sample's T5 observation has a bizarre `13CO2 Mean` number
# (767, order of magnitude higher than any other in the column). Assume drop.
#incdat <- filter(incdat, `HR 13CH4 Mean` < 700)

# ----- Unit conversion -----

incdat %>%
    # BBL: to convert ppm to ml, don't we need to multiply by VOL_ML below?
    # and divide by 1e6? E.g. if we had 1e6 ppm, that's 100% or VOL_ML of CH4
    mutate(cal12CH4ml = `HR 12CH4 Mean` * 2.00013, # ppm to ml and correct for dilution
           cal13CH4ml = `HR 13CH4 Mean` * 2.00013, # multiply by 2.00013
           cal12CH4ml = ifelse(round != "T0", cal12CH4ml * 1.07, cal12CH4ml),
           cal13CH4ml = ifelse(round != "T0", cal13CH4ml * 1.07, cal13CH4ml),
           # calculate atom percent (AP) of 13C methane in sample over time
           AP_obs = cal13CH4ml / (cal12CH4ml + cal13CH4ml) * 100) ->
    incdat

incdat <- filter(incdat, !id %in% c("52"))
#, "52", "4", "71"

incdat %>%
    mutate(id_numeric = as.factor(id)) %>%
    pivot_longer(cols = c(cal12CH4ml, cal13CH4ml, AP_obs)) %>%
    ggplot(aes(round, value, group = id, color = id)) +
    geom_point() + geom_line() +
    ggtitle("POST DATA EXCLUSION") +
    facet_wrap( ~ name, scales = "free") ->
    p
print(p)
ggsave("./outputs/over_time.png", width = 8, height = 5)

# ----- Constants -----

FRAC_K <- 0.98 # 13C consumption as a fraction of 12C consumption (alpha in Eq. 11)
FRAC_P <- 0.01 # 13C production as a fraction of 12C production
AP_P <- FRAC_P / (1 + FRAC_P) * 100 # 13C atom percent of total methane production
VOL_ML <- 100   # Note that currently this isn't used anywhere below

# ----- Model-fitting functions -----

# Prediction function
# time: vector of time values, numeric (e.g. days); first should be zero
# m0: amount of total methane at time zero
# n0: amount of labeled methane at time zero
# P: production rate of total methane, unit gas/unit time
# k: first-order rate constant for methane consumption, 1/unit time
# Returns a data frame with mt, nt, and AP (atom percent) predictions for each t
ap_prediction <- function(time, m0, n0, P, k) {
    # Combined, this is Eq. 11 from von Fischer and Hedin 2002, 10.1029/2001GB001448
    # ...except modified for what I think are two mistakes
    # 1. Added *100 so that the left part is correctly a percent (per their Appendix A)
    # 2. We've just predicted nt and mt, so now doesn't APt flow directly from them?!?
    # How does it make sense to add AP_P (as in vF&H eq. 10 and 11)?
    # para 14: "APp is the atom percent 13C of methane generated by methane production"
    # para 15: "there is no production of labeled methane during incubation"

    # Equation 9 (and numerator in Eq. 11):
    kfrac <- k * FRAC_K
    pfrac <- P * FRAC_P
    nt <- pfrac/kfrac - (pfrac/kfrac - n0) * exp(-kfrac * time)
    # Equation 5 (and denominator in Eq. 11):
    mt <- P/k - (P/k - m0) * exp(-k * time)

    tibble(mt = mt,
           nt = nt,
           # Modified Equation 10/11
           AP_pred =  nt / mt * 100) # + AP_P
}

# Cost function called by optim()
# params: named vector holding optimizer-assigned values for P and k
# time: vector of time values, numeric (e.g. days); first should be zero
# m: observed total methane values, same length as time
# n0: amount of labeled methane at time zero
# AP_obs: time series of observed atom percent for 13C
# Returns the sum of squares between predicted and observed m and AP
cost_function <- function(params, time, m, n, AP_obs) {
    #    message(params["P"], ",", params["k"])
    pred <- ap_prediction(time = time,
                          m0 = m[1],
                          n0 = n[1],
                          P = params["P"],
                          k = params["k"])

    # m and AP are on different scales, so we need to scale them
    # in order to combine for a single sum of squares calculation
    # First find overall ranges...
    m_range <- range(c(pred$mt, m, na.rm = TRUE))
    n_range <- range(c(pred$nt, n, na.rm = TRUE))
    # ...and then rescale
    library(scales)
    mt_r <- rescale(pred$mt, from = m_range)
    nt_r <- rescale(pred$nt, from = n_range)
    m_r <- rescale(m, from = m_range)
    n_r <- rescale(n, from = n_range)
    # Return overall sum of squares to the optimizer
    sum((c(mt_r, nt_r) - c(m_r, n_r)) ^ 2)
}


# ----- Main -----

pk_results <- list()
incdat_out <- list()

for(i in unique(incdat$id)) {
    message("------------------- ", i)
    # Isolate this sample's data
    incdat %>%
        filter(id == i) %>%
        select(id, round, vol, time_days, cal12CH4ml, cal13CH4ml, AP_obs) ->
        dat

    # Estimate starting k by slope of 13C
    # This follows paragraph 21 in section 2.4
    # "We then calculate k as the slope of the linear regression of ln(n)
    # versus time...
    m <- lm(log(cal13CH4ml) ~ time_days, data = dat)
    m_slope <- unname(m$coefficients["time_days"])
    message("m_slope = ", m_slope)
    if(m_slope >= 0) {
        stop("Slope of 13CH4 over time is positive; this should not happen")
    }
    # "...multiplied by 1/a to correct for fractionation against the
    # labeled methane."
    # BBL: this should be "1/-a" (see equation 8)
    k0 = m_slope / -FRAC_K
    message("k0 = ", k0)
    # From k, we calculate the gross methane consumption rate
    # at atmospheric concentrations of methane (i.e., 1.8 mL/L) using equation (3).

    # Let optim() try different values for P and k until it finds best fit to data
    result <- optim(par = c("P" = 0.01, "k"= k0),
                    fn = cost_function,
                    # Constrain the optimizer so it can't produce <0 values
                    # for P, nor values >=0 for k
                    method = "L-BFGS-B",
                    lower = c("P" = 0.0, "k"= 0.0001),
                    upper = c("P" = Inf, "k"= Inf),

                    # "..." that the optimizer will pass to cost_function:
                    time = dat$time_days,
                    m = dat$cal12CH4ml + dat$cal13CH4ml,
                    n = dat$cal13CH4ml,
                    AP_obs = dat$AP_obs)

    message("Optimizer solution:")
    print(result)
    P <- result$par["P"]
    pk_results[[i]] <- tibble(P = P,
                              k = result$par["k"],
                              k0 = k0,
                              convergence = result$convergence,
                              message = result$message)

    # Predict based on the optimized parameters
    sample_rows <- incdat$id == i
    pred <- ap_prediction(time = dat$time_days,
                          m0 = dat$cal12CH4ml[1] + dat$cal13CH4ml[1],
                          n0 = dat$cal13CH4ml[1],
                          P = P,
                          k = result$par["k"])
    dat <- bind_cols(dat, pred)

    # Calculate implied consumption (ml/day) based on predictions
    # Ct = (P*time - ([CH4t] - [CH4t-1]))/time
    # or expressed in the notation of Equation 4: dm/dt = P - C
    # so C = P - dm/dt
    total_methane <- dat$cal12CH4ml + dat$cal13CH4ml
    change_methane <- c(0, diff(total_methane))
    change_time <- c(0, diff(dat$time_days))
    dat$Pt <- P * change_time
    dat$Ct <- (-change_methane + (P * change_time)) / change_time
    #for 52, predicted P (for each time step) is too low
    #to account for change_methane at each time step

    incdat_out[[i]] <- dat
}

pk_results <- bind_rows(pk_results, .id = "id")
incdat_out <- bind_rows(incdat_out)


# ----- Plot AP results -----

ap_pred <- ggplot(incdat_out, aes(time_days)) +
    geom_point(aes(y = AP_obs)) +
    geom_line(aes(y = AP_pred), linetype = 2) +
    facet_wrap(~as.numeric(id), scales = "free") +
    geom_text(data = pk_results, x = 0.6, y = 1.5,
              aes(label = paste("P =", format(P, digits = 1, nsmall = 1)))) +
    geom_text(data = pk_results, x = 0.6, y = 1.4,
              aes(label = paste("k =", format(k, digits = 2, nsmall = 2))))
print(ap_pred)
ggsave("./outputs/ap_pred.png", width = 8, height = 6)


# ----- Plot total methane results -----

m_pred <- ggplot(incdat_out, aes(time_days)) +
    geom_point(aes(y = cal12CH4ml + cal13CH4ml)) +
    geom_line(aes(y = mt), linetype = 2) +
    facet_wrap(~as.numeric(id), scales = "free")
print(m_pred)
ggsave("./outputs/m_pred.png", width = 8, height = 6)

print(pk_results)

message("All done.")

#multiply k by overall average mls of methane
# pk_results$ml_k <- pk_results$k * 3
# pk_results$net <- pk_results$P + pk_results$ml_k
#
# pk_results %>%
#     filter(net > 0) -> issues
# unique(issues$id)
# lm_issues <- c("44", "52", "58", "59", "71", "72")
# ln_lm_issues <- c("18", "19", "3", "30", "31", "32", "41", "61", "71", "72", "86")
#
#
# pk_results %>%
#     filter(k > 0) -> same
# unique(same$id)
#
# lm_same <- c("44", "52", "58", "59", "71")
# ln_lm_same <- c("18", "3", "32", "41", "61", "71", "86")
#
# intersect(lm_issues, ln_lm_issues)
# intersect(lm_same, ln_lm_same)
#
# #write.csv(pk_results, "27092022_results.csv")

